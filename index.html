<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D無限生成ゲーム</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #canvasWrapper {
            width: 100vw;
            height: 100vh;
            cursor: none;
        }
    </style>
</head>
<body>
    <div id="canvasWrapper">
        <canvas id="gameCanvas"></canvas>
    </div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.168.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.168.0/examples/jsm/",
                "three/addons/math/ImprovedNoise.js": "https://unpkg.com/three@0.168.0/examples/jsm/math/ImprovedNoise.js"
            }
        }
    </script>
        <script type="module">
            // Step 11: Perlinノイズによる簡単な地形生成
            import * as THREE from 'three';
            import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
            // --- Step 11 で追加したコード: Perlinノイズライブラリのインポート ---
            import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
        const CHUNK_SIZE = 32;
        const TERRAIN_RESOLUTION = 16;
        const RENDER_DISTANCE = 2;

        function worldToChunkCoord(worldCoord) {
            return Math.floor(worldCoord / CHUNK_SIZE);
        }

        function calculateVisibleChunks(playerChunkX, playerChunkY, playerChunkZ) {
            const chunksToLoad = [];
            for (let dx = -RENDER_DISTANCE; dx <= RENDER_DISTANCE; dx++) {
                for (let dy = -RENDER_DISTANCE; dy <= RENDER_DISTANCE; dy++) {
                    for (let dz = -RENDER_DISTANCE; dz <= RENDER_DISTANCE; dz++) {
                        const cx = playerChunkX + dx;
                        const cy = playerChunkY + dy;
                        const cz = playerChunkZ + dz;
                        chunksToLoad.push({ cx, cy, cz });
                    }
                }
            }
            return chunksToLoad;
        }

        const playerPosition = new THREE.Vector3(50, 1, -25);
        const PLAYER_SPEED = 10.0;

        const scene = new THREE.Scene();
        let playerChunkX = worldToChunkCoord(playerPosition.x);
        let playerChunkY = worldToChunkCoord(playerPosition.y);
        let playerChunkZ = worldToChunkCoord(playerPosition.z);

        console.log(`プレイヤーの初期位置: (${playerPosition.x}, ${playerPosition.y}, ${playerPosition.z}) m`);
        console.log(`プレイヤーの初期所属チャンク: (${playerChunkX}, ${playerChunkY}, ${playerChunkZ})`);

        const loadedChunks = new Map();

        function getChunkKey(chunkCoord) {
             return `${chunkCoord.cx},${chunkCoord.cy},${chunkCoord.cz}`;
        }

        // --- Step 15 で変更したコード: 地形メッシュにシャドウ設定を追加 ---
        function createNoiseTerrain(cx, cy, cz) {
            const perlin = new ImprovedNoise();
            const geometry = new THREE.BufferGeometry();
            const material = new THREE.MeshStandardMaterial({
                color: 0x00aa00,
                wireframe: false,
                flatShading: false
            });

            const segments = TERRAIN_RESOLUTION;
            const vertices = [];
            const indices = [];
            const uvs = [];

            const halfSize = CHUNK_SIZE / 2;
            const segmentSize = CHUNK_SIZE / segments;

            for (let z = 0; z <= segments; z++) {
                for (let x = 0; x <= segments; x++) {
                    const localX = x * segmentSize;
                    const localZ = z * segmentSize;
                    const worldX = cx * CHUNK_SIZE + localX;
                    const worldZ = cz * CHUNK_SIZE + localZ;
                    const scale = 0.05;
                    const height = perlin.noise(worldX * scale, 0, worldZ * scale) * 5;
                    const worldY = cy * CHUNK_SIZE + height;
                    vertices.push(localX - halfSize, worldY, localZ - halfSize);
                    uvs.push(x / segments, 1 - z / segments);
                }
            }

            for (let z = 0; z < segments; z++) {
                for (let x = 0; x < segments; x++) {
                    const a = x + (segments + 1) * z;
                    const b = x + (segments + 1) * (z + 1);
                    const c = (x + 1) + (segments + 1) * (z + 1);
                    const d = (x + 1) + (segments + 1) * z;
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }

            geometry.setIndex(indices);
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            geometry.computeVertexNormals();

            const terrainMesh = new THREE.Mesh(geometry, material);
            terrainMesh.position.set(
                chunkToWorldCenter(cx),
                0,
                chunkToWorldCenter(cz)
            );
            // --- Step 15 で追加したコード: 地形メッシュのシャドウ設定 ---
            terrainMesh.receiveShadow = true; // 地形は影を受ける
            terrainMesh.castShadow = true;    // 地形は影を落とす
            // --- Step 15 のコード ここまで ---
            return terrainMesh;
        }
        // --- Step 15 のコード ここまで ---

        function getTerrainHeightAt(x, z) {
            const chunkX = worldToChunkCoord(x);
            const chunkZ = worldToChunkCoord(z);
            const chunkY = playerChunkY;

            const key = getChunkKey({cx: chunkX, cy: chunkY, cz: chunkZ});
            const chunkData = loadedChunks.get(key);

            if (!chunkData || !chunkData.terrain) {
                return chunkY * CHUNK_SIZE;
            }

            return chunkY * CHUNK_SIZE;
        }

        function loadChunk(chunkCoord) {
            const key = getChunkKey(chunkCoord);
            if (loadedChunks.has(key)) {
                return;
            }

            let color = 0xffffff;
            if (chunkCoord.cx === playerChunkX && chunkCoord.cy === playerChunkY && chunkCoord.cz === playerChunkZ) {
                color = 0xffff00;
            }

            const chunkGroup = new THREE.Group();
            chunkGroup.name = `chunk_${key}`;

            const wireframe = createChunkWireframe(chunkCoord.cx, chunkCoord.cy, chunkCoord.cz, color);
            const terrain = createNoiseTerrain(chunkCoord.cx, chunkCoord.cy, chunkCoord.cz);

            chunkGroup.add(wireframe);
            chunkGroup.add(terrain);

            placeTreesInChunk(chunkGroup, chunkCoord.cx, chunkCoord.cz);

            scene.add(chunkGroup);

            loadedChunks.set(key, { group: chunkGroup, wireframe, terrain });
        }

        function unloadChunk(key) {
            const chunkData = loadedChunks.get(key);
            if (!chunkData) {
                return;
            }

            scene.remove(chunkData.group);

            if (chunkData.terrain) {
                chunkData.terrain.geometry.dispose();
                chunkData.terrain.material.dispose();
            }
            if (chunkData.wireframe) {
                chunkData.wireframe.geometry.dispose();
                chunkData.wireframe.material.dispose();
            }

            loadedChunks.delete(key);
        }

        const initialVisibleChunks = calculateVisibleChunks(playerChunkX, playerChunkY, playerChunkZ);
        initialVisibleChunks.forEach(chunkCoord => {
             loadChunk(chunkCoord);
        });
        console.log(`初期ロード: ${initialVisibleChunks.length} 個のチャンクをロードしました。`);

        function chunkToWorldCenter(chunkCoord) {
            return chunkCoord * CHUNK_SIZE + CHUNK_SIZE / 2;
        }

        function createChunkWireframe(cx, cy, cz, color = 0xffffff) {
            const chunkGeometry = new THREE.BoxGeometry(CHUNK_SIZE, CHUNK_SIZE, CHUNK_SIZE);
            const edgesGeometry = new THREE.EdgesGeometry(chunkGeometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: 1 });
            const chunkWireframe = new THREE.LineSegments(edgesGeometry, lineMaterial);
            const centerX = chunkToWorldCenter(cx);
            const centerY = chunkToWorldCenter(cy);
            const centerZ = chunkToWorldCenter(cz);
            chunkWireframe.position.set(centerX, centerY, centerZ);
            return chunkWireframe;
        }

        // --- Step 14/15 で変更/追加したコード: 木のランダム化とシャドウ設定 ---
        function createTree() {
            const treeGroup = new THREE.Group();

            const trunkHeight = 2 + Math.random() * 4;
            const trunkTopRadius = 0.1 + Math.random() * 0.3;
            const trunkBottomRadius = trunkTopRadius + 0.05 + Math.random() * 0.2;
            const leavesRadius = 1.0 + Math.random() * 2.0;

            const leafHue = 0.3 + Math.random() * 0.1;
            const leafSaturation = 0.5 + Math.random() * 0.5;
            const leafLightness = 0.2 + Math.random() * 0.3;
            const leafColor = new THREE.Color(`hsl(${leafHue * 360}, ${leafSaturation * 100}%, ${leafLightness * 100}%)`);

            const trunkHue = 0.1;
            const trunkSaturation = 0.3 + Math.random() * 0.3;
            const trunkLightness = 0.1 + Math.random() * 0.2;
            const trunkColor = new THREE.Color(`hsl(${trunkHue * 360}, ${trunkSaturation * 100}%, ${trunkLightness * 100}%)`);

            const trunkGeometry = new THREE.CylinderGeometry(trunkTopRadius, trunkBottomRadius, trunkHeight, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: trunkColor });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = trunkHeight / 2;
            // --- Step 15 で追加したコード: 茎のシャドウ設定 ---
            trunk.castShadow = true;    // 茎は影を落とす
            trunk.receiveShadow = true; // 茎は影を受ける（例: 他の木の影）
            // --- Step 15 のコード ここまで ---
            treeGroup.add(trunk);

            const leavesGeometry = new THREE.SphereGeometry(leavesRadius, 8, 8);
            const leavesMaterial = new THREE.MeshStandardMaterial({ color: leafColor });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.y = trunkHeight + leavesRadius * 0.7;
            // --- Step 15 で追加したコード: 葉のシャドウ設定 ---
            leaves.castShadow = true;    // 葉は影を落とす
            leaves.receiveShadow = true; // 葉は影を受ける
            // --- Step 15 のコード ここまで ---
            treeGroup.add(leaves);

            return treeGroup;
        }

        function placeTreesInChunk(chunkGroup, cx, cz) {
            const numTrees = Math.floor(Math.random() * 20) + 5;

            const halfChunkSize = CHUNK_SIZE / 2;

            for (let i = 0; i < numTrees; i++) {
                const localX = Math.random() * CHUNK_SIZE;
                const localZ = Math.random() * CHUNK_SIZE;
                const worldX = cx * CHUNK_SIZE + localX;
                const worldZ = cz * CHUNK_SIZE + localZ;
                const terrainHeight = getTerrainHeightAt(worldX, worldZ);

                const tree = createTree();
                tree.position.set(
                    localX - halfChunkSize,
                    terrainHeight,
                    localZ - halfChunkSize
                );
                chunkGroup.add(tree);
            }
        }
        // --- Step 14/15 のコード ここまで ---

        let isFirstPersonView = true;

        function toggleViewMode() {
            isFirstPersonView = !isFirstPersonView;
            if (isFirstPersonView) {
                playerMesh.visible = false;
                camera.position.set(0, 1.6, 0);
                console.log("視点を一人称に切り替えました。");
            } else {
                playerMesh.visible = true;
                camera.position.set(0, 2, -3);
                console.log("視点を三人称に切り替えました。");
            }
        }

        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            10000
        );

        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        // --- Step 15 で追加したコード: レンダラーのシャドウマップ設定 ---
        renderer.shadowMap.enabled = true; // シャドウマップを有効化
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // 影のタイプをソフトシャドウに設定
        // --- Step 15 のコード ここまで ---

        // --- Step 15 で変更したコード: 環境光の強度を少し下げる ---
        const ambientLight = new THREE.AmbientLight(0x404040); // 強度を 0x606060 から 0x404040 に変更
        scene.add(ambientLight);
        // --- Step 15 のコード ここまで ---

        // --- Step 15 で変更/追加したコード: ディレクショナルライトのシャドウ設定 ---
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 0.5).normalize();
        // --- Step 15 で追加したコード: ディレクショナルライトのシャドウ設定 ---
        directionalLight.castShadow = true; // ライトが影を落とすことを許可

        // シャドウマップの解像度を設定 (大きいほど高品質だが重い)
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;

        // シャドウを計算する範囲（ライトから見たカメラの視錐台）を設定
        // 単位はワールド座標
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        // --- Step 15 のコード ここまで ---
        scene.add(directionalLight);
        // --- Step 15 のコード ここまで ---

        const playerGeometry = new THREE.BoxGeometry(1, 2, 1);
        const playerMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
        playerMesh.position.copy(playerPosition);
        // --- Step 15 で追加したコード: プレイヤーメッシュのシャドウ設定 ---
        playerMesh.castShadow = true;    // プレイヤーは影を落とす
        playerMesh.receiveShadow = false; // プレイヤーは影を受けない（オプション）
        // --- Step 15 のコード ここまで ---
        scene.add(playerMesh);
        console.log("プレイヤーメッシュを追加しました。");

        playerMesh.add(camera);
        camera.position.set(0, 1.6, 0);
        camera.rotation.set(0, 0, 0);
        playerMesh.visible = false;

        const MOUSE_SENSITIVITY = 0.002;
        let playerRotationX = 0;
        const PLAYER_ROTATION_X_MIN = -Math.PI / 2 + 0.1;
        const PLAYER_ROTATION_X_MAX = Math.PI / 2 - 0.1;
        let isPointerLocked = false;
        const canvasWrapper = document.getElementById('canvasWrapper');

        canvasWrapper.addEventListener('click', () => {
            if (!isPointerLocked) {
                canvasWrapper.requestPointerLock();
            }
        });

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = (document.pointerLockElement === canvasWrapper);
            console.log('Pointer Lock:', isPointerLocked ? 'ON' : 'OFF');
        });

        document.addEventListener('mousemove', (event) => {
            if (isPointerLocked) {
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;

                playerMesh.rotation.y -= movementX * MOUSE_SENSITIVITY;
                playerRotationX -= movementY * MOUSE_SENSITIVITY;
                playerRotationX = Math.max(PLAYER_ROTATION_X_MIN, Math.min(PLAYER_ROTATION_X_MAX, playerRotationX));
                camera.rotation.x = playerRotationX;
            }
        });

        const axesHelper = new THREE.AxesHelper(5);
        playerMesh.add(axesHelper);

        const keyState = {};
        window.addEventListener('keydown', (event) => {
            keyState[event.code] = true;

            if (event.code === 'KeyV') {
                toggleViewMode();
            }
        });
        window.addEventListener('keyup', (event) => {
            keyState[event.code] = false;
        });

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            const playerDirection = playerMesh.rotation.y;

            let moveX = 0;
            let moveZ = 0;

            if (keyState['KeyW']) {
                moveX -= Math.sin(playerDirection) * PLAYER_SPEED * delta;
                moveZ -= Math.cos(playerDirection) * PLAYER_SPEED * delta;
            }
            if (keyState['KeyS']) {
                moveX += Math.sin(playerDirection) * PLAYER_SPEED * delta;
                moveZ += Math.cos(playerDirection) * PLAYER_SPEED * delta;
            }
            if (keyState['KeyA']) {
                moveX -= Math.cos(playerDirection) * PLAYER_SPEED * delta;
                moveZ += Math.sin(playerDirection) * PLAYER_SPEED * delta;
            }
            if (keyState['KeyD']) {
                moveX += Math.cos(playerDirection) * PLAYER_SPEED * delta;
                moveZ -= Math.sin(playerDirection) * PLAYER_SPEED * delta;
            }

            playerMesh.position.x += moveX;
            playerMesh.position.z += moveZ;

            const terrainHeight = getTerrainHeightAt(playerMesh.position.x, playerMesh.position.z);
            playerMesh.position.y = terrainHeight + 1;

            const newPlayerChunkX = worldToChunkCoord(playerMesh.position.x);
            const newPlayerChunkY = worldToChunkCoord(playerMesh.position.y);
            const newPlayerChunkZ = worldToChunkCoord(playerMesh.position.z);

            if (newPlayerChunkX !== playerChunkX || newPlayerChunkY !== playerChunkY || newPlayerChunkZ !== playerChunkZ) {
                playerChunkX = newPlayerChunkX;
                playerChunkY = newPlayerChunkY;
                playerChunkZ = newPlayerChunkZ;

                const newVisibleChunks = calculateVisibleChunks(playerChunkX, playerChunkY, playerChunkZ);

                const newChunkKeysSet = new Set();
                newVisibleChunks.forEach(coord => newChunkKeysSet.add(getChunkKey(coord)));

                const keysToUnload = [];
                for (const key of loadedChunks.keys()) {
                    if (!newChunkKeysSet.has(key)) {
                         keysToUnload.push(key);
                    }
                }
                keysToUnload.forEach(key => unloadChunk(key));

                newVisibleChunks.forEach(coord => {
                     const key = getChunkKey(coord);
                     if (!loadedChunks.has(key)) {
                          loadChunk(coord);
                     }
                });

                console.log(`チャンク更新: ${keysToUnload.length} 個アンロード, ${newVisibleChunks.length - (loadedChunks.size - keysToUnload.length)} 個ロード`);
            }

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
        });

        console.log("Scene, Camera, Renderer, Player, Dynamic Chunk Loading, Noise-based Terrain, Randomized Trees, First-Person View, and Shadows initialized.");
        console.log("Click to lock pointer. WASD to move. Mouse to look around. Press 'V' to toggle view mode (FPS/TPS). Shadows are enabled.");
        // --- 以前のコード ここまで ---

    </script>
</body>
</html>