<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D無限生成ゲーム</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #canvasWrapper {
            width: 100vw;
            height: 100vh;
            cursor: none;
        }
    </style>
</head>
<body>
    <div id="canvasWrapper">
        <canvas id="gameCanvas"></canvas>
    </div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.168.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.168.0/examples/jsm/",
                "three/addons/math/ImprovedNoise.js": "https://unpkg.com/three@0.168.0/examples/jsm/math/ImprovedNoise.js"
            }
        }
    </script>
        <script type="module">
            // Step 11: Perlinノイズによる簡単な地形生成
            import * as THREE from 'three';
            import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
            // --- Step 11 で追加したコード: Perlinノイズライブラリのインポート ---
            import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
        const CHUNK_SIZE = 32;
        const TERRAIN_RESOLUTION = 16;
        const RENDER_DISTANCE = 2;

        function worldToChunkCoord(worldCoord) {
            return Math.floor(worldCoord / CHUNK_SIZE);
        }

        function calculateVisibleChunks(playerChunkX, playerChunkY, playerChunkZ) {
            const chunksToLoad = [];
            for (let dx = -RENDER_DISTANCE; dx <= RENDER_DISTANCE; dx++) {
                for (let dy = -RENDER_DISTANCE; dy <= RENDER_DISTANCE; dy++) {
                    for (let dz = -RENDER_DISTANCE; dz <= RENDER_DISTANCE; dz++) {
                        const cx = playerChunkX + dx;
                        const cy = playerChunkY + dy;
                        const cz = playerChunkZ + dz;
                        chunksToLoad.push({ cx, cy, cz });
                    }
                }
            }
            return chunksToLoad;
        }

        const playerPosition = new THREE.Vector3(50, 1, -25);
        const PLAYER_SPEED = 10.0;

        const scene = new THREE.Scene();
        let playerChunkX = worldToChunkCoord(playerPosition.x);
        let playerChunkY = worldToChunkCoord(playerPosition.y);
        let playerChunkZ = worldToChunkCoord(playerPosition.z);

        console.log(`プレイヤーの初期位置: (${playerPosition.x}, ${playerPosition.y}, ${playerPosition.z}) m`);
        console.log(`プレイヤーの初期所属チャンク: (${playerChunkX}, ${playerChunkY}, ${playerChunkZ})`);

        const loadedChunks = new Map();
        // --- Step 16 で追加したコード: ロードされたチェストを管理する配列 ---
        const loadedChests = []; // チェストメッシュを直接格納する配列
        // --- Step 16 のコード ここまで ---

        function getChunkKey(chunkCoord) {
             return `${chunkCoord.cx},${chunkCoord.cy},${chunkCoord.cz}`;
        }

        function createNoiseTerrain(cx, cy, cz) {
            const perlin = new ImprovedNoise();
            const geometry = new THREE.BufferGeometry();
            const material = new THREE.MeshStandardMaterial({
                color: 0x00aa00,
                wireframe: false,
                flatShading: false
            });

            const segments = TERRAIN_RESOLUTION;
            const vertices = [];
            const indices = [];
            const uvs = [];

            const halfSize = CHUNK_SIZE / 2;
            const segmentSize = CHUNK_SIZE / segments;

            for (let z = 0; z <= segments; z++) {
                for (let x = 0; x <= segments; x++) {
                    const localX = x * segmentSize;
                    const localZ = z * segmentSize;
                    const worldX = cx * CHUNK_SIZE + localX;
                    const worldZ = cz * CHUNK_SIZE + localZ;
                    const scale = 0.05;
                    const height = perlin.noise(worldX * scale, 0, worldZ * scale) * 5;
                    const worldY = cy * CHUNK_SIZE + height;
                    vertices.push(localX - halfSize, worldY, localZ - halfSize);
                    uvs.push(x / segments, 1 - z / segments);
                }
            }

            for (let z = 0; z < segments; z++) {
                for (let x = 0; x < segments; x++) {
                    const a = x + (segments + 1) * z;
                    const b = x + (segments + 1) * (z + 1);
                    const c = (x + 1) + (segments + 1) * (z + 1);
                    const d = (x + 1) + (segments + 1) * z;
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }

            geometry.setIndex(indices);
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            geometry.computeVertexNormals();

            const terrainMesh = new THREE.Mesh(geometry, material);
            terrainMesh.position.set(
                chunkToWorldCenter(cx),
                0,
                chunkToWorldCenter(cz)
            );
            terrainMesh.receiveShadow = true;
            terrainMesh.castShadow = true;
            return terrainMesh;
        }

        function getTerrainHeightAt(x, z) {
            const chunkX = worldToChunkCoord(x);
            const chunkZ = worldToChunkCoord(z);
            const chunkY = playerChunkY;

            const key = getChunkKey({cx: chunkX, cy: chunkY, cz: chunkZ});
            const chunkData = loadedChunks.get(key);

            if (!chunkData || !chunkData.terrain) {
                return chunkY * CHUNK_SIZE;
            }

            return chunkY * CHUNK_SIZE;
        }

        // --- Step 16 で追加したコード: チェストの作成 ---
        /**
         * 簡単なチェストメッシュを生成する
         * @returns {THREE.Mesh} チェストメッシュ
         */
        function createChest() {
            // チェストのジオメトリ (箱)
            const chestGeometry = new THREE.BoxGeometry(1, 0.8, 0.6); // 幅, 高さ, 奥行き
            // チェストのマテリアル (茶色)
            const chestMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            // メッシュ作成
            const chestMesh = new THREE.Mesh(chestGeometry, chestMaterial);
            // シャドウ設定
            chestMesh.castShadow = true;
            chestMesh.receiveShadow = true;
            // チェストの中心が地面に接するように、Y位置を少し調整
            // chestMesh.position.y は配置時に設定
            return chestMesh;
        }
        // --- Step 16 のコード ここまで ---

        // --- Step 16 で追加したコード: チャンク内にチェストを配置 ---
        /**
         * 指定されたチャンク内にチェストをランダムに配置する
         * @param {THREE.Group} chunkGroup - チャンクのグループ
         * @param {number} cx - チャンクX座標
         * @param {number} cz - チャンクZ座標
         */
        function placeChestsInChunk(chunkGroup, cx, cz) {
            // 1. チェストを配置するかどうかをランダムに決定 (例: 30%の確率で配置)
            if (Math.random() > 0.3) {
                return; // 70%の確率で配置しない
            }

            // 2. チャンク内でのランダムなローカルXZ座標を決定
            const localX = Math.random() * CHUNK_SIZE;
            const localZ = Math.random() * CHUNK_SIZE;

            // 3. ローカル座標をワールド座標に変換
            const worldX = cx * CHUNK_SIZE + localX;
            const worldZ = cz * CHUNK_SIZE + localZ;

            // 4. その地点の地形の高さを取得
            const terrainHeight = getTerrainHeightAt(worldX, worldZ);

            // 5. チェストメッシュを作成
            const chest = createChest();

            // 6. チェストの位置を設定 (ローカル座標系でチャンクグループ内に配置)
            const halfChunkSize = CHUNK_SIZE / 2;
            chest.position.set(
                localX - halfChunkSize,
                terrainHeight, // 地面の高さに配置
                localZ - halfChunkSize
            );

            // 7. チャンクグループに追加
            chunkGroup.add(chest);

            // 8. ロードされたチェストリストに追加
            loadedChests.push(chest);
        }
        // --- Step 16 のコード ここまで ---

        function loadChunk(chunkCoord) {
            const key = getChunkKey(chunkCoord);
            if (loadedChunks.has(key)) {
                return;
            }

            let color = 0xffffff;
            if (chunkCoord.cx === playerChunkX && chunkCoord.cy === playerChunkY && chunkCoord.cz === playerChunkZ) {
                color = 0xffff00;
            }

            const chunkGroup = new THREE.Group();
            chunkGroup.name = `chunk_${key}`;

            const wireframe = createChunkWireframe(chunkCoord.cx, chunkCoord.cy, chunkCoord.cz, color);
            const terrain = createNoiseTerrain(chunkCoord.cx, chunkCoord.cy, chunkCoord.cz);

            chunkGroup.add(wireframe);
            chunkGroup.add(terrain);

            placeTreesInChunk(chunkGroup, chunkCoord.cx, chunkCoord.cz);
            // --- Step 16 で追加したコード: チェストの配置呼び出し ---
            placeChestsInChunk(chunkGroup, chunkCoord.cx, chunkCoord.cz);
            // --- Step 16 のコード ここまで ---

            scene.add(chunkGroup);

            loadedChunks.set(key, { group: chunkGroup, wireframe, terrain });
        }

        // --- Step 16 で変更したコード: チャンクアンロード時にチェストも削除 ---
        function unloadChunk(key) {
            const chunkData = loadedChunks.get(key);
            if (!chunkData) {
                return;
            }

            // チャンクグループ内のチェストを loadedChests から削除
            // これを行うには、グループ内のオブジェクトを走査する必要がある
            chunkData.group.traverse((child) => {
                // loadedChests 配列から child (chest mesh) を探して削除
                const chestIndex = loadedChests.indexOf(child);
                if (chestIndex !== -1) {
                    loadedChests.splice(chestIndex, 1);
                    // console.log("チェストをアンロードリストから削除しました。"); // デバッグ用
                }
            });

            scene.remove(chunkData.group);

            if (chunkData.terrain) {
                chunkData.terrain.geometry.dispose();
                chunkData.terrain.material.dispose();
            }
            if (chunkData.wireframe) {
                chunkData.wireframe.geometry.dispose();
                chunkData.wireframe.material.dispose();
            }

            loadedChunks.delete(key);
        }
        // --- Step 16 のコード ここまで ---

        const initialVisibleChunks = calculateVisibleChunks(playerChunkX, playerChunkY, playerChunkZ);
        initialVisibleChunks.forEach(chunkCoord => {
             loadChunk(chunkCoord);
        });
        console.log(`初期ロード: ${initialVisibleChunks.length} 個のチャンクをロードしました。`);

        function chunkToWorldCenter(chunkCoord) {
            return chunkCoord * CHUNK_SIZE + CHUNK_SIZE / 2;
        }

        function createChunkWireframe(cx, cy, cz, color = 0xffffff) {
            const chunkGeometry = new THREE.BoxGeometry(CHUNK_SIZE, CHUNK_SIZE, CHUNK_SIZE);
            const edgesGeometry = new THREE.EdgesGeometry(chunkGeometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: 1 });
            const chunkWireframe = new THREE.LineSegments(edgesGeometry, lineMaterial);
            const centerX = chunkToWorldCenter(cx);
            const centerY = chunkToWorldCenter(cy);
            const centerZ = chunkToWorldCenter(cz);
            chunkWireframe.position.set(centerX, centerY, centerZ);
            return chunkWireframe;
        }

        function createTree() {
            const treeGroup = new THREE.Group();

            const trunkHeight = 2 + Math.random() * 4;
            const trunkTopRadius = 0.1 + Math.random() * 0.3;
            const trunkBottomRadius = trunkTopRadius + 0.05 + Math.random() * 0.2;
            const leavesRadius = 1.0 + Math.random() * 2.0;

            const leafHue = 0.3 + Math.random() * 0.1;
            const leafSaturation = 0.5 + Math.random() * 0.5;
            const leafLightness = 0.2 + Math.random() * 0.3;
            const leafColor = new THREE.Color(`hsl(${leafHue * 360}, ${leafSaturation * 100}%, ${leafLightness * 100}%)`);

            const trunkHue = 0.1;
            const trunkSaturation = 0.3 + Math.random() * 0.3;
            const trunkLightness = 0.1 + Math.random() * 0.2;
            const trunkColor = new THREE.Color(`hsl(${trunkHue * 360}, ${trunkSaturation * 100}%, ${trunkLightness * 100}%)`);

            const trunkGeometry = new THREE.CylinderGeometry(trunkTopRadius, trunkBottomRadius, trunkHeight, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: trunkColor });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            treeGroup.add(trunk);

            const leavesGeometry = new THREE.SphereGeometry(leavesRadius, 8, 8);
            const leavesMaterial = new THREE.MeshStandardMaterial({ color: leafColor });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.y = trunkHeight + leavesRadius * 0.7;
            leaves.castShadow = true;
            leaves.receiveShadow = true;
            treeGroup.add(leaves);

            return treeGroup;
        }

        function placeTreesInChunk(chunkGroup, cx, cz) {
            const numTrees = Math.floor(Math.random() * 20) + 5;

            const halfChunkSize = CHUNK_SIZE / 2;

            for (let i = 0; i < numTrees; i++) {
                const localX = Math.random() * CHUNK_SIZE;
                const localZ = Math.random() * CHUNK_SIZE;
                const worldX = cx * CHUNK_SIZE + localX;
                const worldZ = cz * CHUNK_SIZE + localZ;
                const terrainHeight = getTerrainHeightAt(worldX, worldZ);

                const tree = createTree();
                tree.position.set(
                    localX - halfChunkSize,
                    terrainHeight,
                    localZ - halfChunkSize
                );
                chunkGroup.add(tree);
            }
        }

        let isFirstPersonView = true;

        function toggleViewMode() {
            isFirstPersonView = !isFirstPersonView;
            if (isFirstPersonView) {
                playerMesh.visible = false;
                camera.position.set(0, 1.6, 0);
                console.log("視点を一人称に切り替えました。");
            } else {
                playerMesh.visible = true;
                camera.position.set(0, 2, -3);
                console.log("視点を三人称に切り替えました。");
            }
        }

        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            10000
        );

        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 0.5).normalize();
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        scene.add(directionalLight);

        const playerGeometry = new THREE.BoxGeometry(1, 2, 1);
        const playerMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
        playerMesh.position.copy(playerPosition);
        playerMesh.castShadow = true;
        playerMesh.receiveShadow = false;
        scene.add(playerMesh);
        console.log("プレイヤーメッシュを追加しました。");

        playerMesh.add(camera);
        camera.position.set(0, 1.6, 0);
        camera.rotation.set(0, 0, 0);
        playerMesh.visible = false;

        const MOUSE_SENSITIVITY = 0.002;
        let playerRotationX = 0;
        const PLAYER_ROTATION_X_MIN = -Math.PI / 2 + 0.1;
        const PLAYER_ROTATION_X_MAX = Math.PI / 2 - 0.1;
        let isPointerLocked = false;
        const canvasWrapper = document.getElementById('canvasWrapper');

        canvasWrapper.addEventListener('click', () => {
            if (!isPointerLocked) {
                canvasWrapper.requestPointerLock();
            }
        });

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = (document.pointerLockElement === canvasWrapper);
            console.log('Pointer Lock:', isPointerLocked ? 'ON' : 'OFF');
        });

        document.addEventListener('mousemove', (event) => {
            if (isPointerLocked) {
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;

                playerMesh.rotation.y -= movementX * MOUSE_SENSITIVITY;
                playerRotationX -= movementY * MOUSE_SENSITIVITY;
                playerRotationX = Math.max(PLAYER_ROTATION_X_MIN, Math.min(PLAYER_ROTATION_X_MAX, playerRotationX));
                camera.rotation.x = playerRotationX;
            }
        });

        const axesHelper = new THREE.AxesHelper(5);
        playerMesh.add(axesHelper);

        // --- Step 16 で変更したコード: キー入力処理の拡張 ---
        const keyState = {};
        window.addEventListener('keydown', (event) => {
            keyState[event.code] = true;

            if (event.code === 'KeyV') {
                toggleViewMode();
            }
            // --- Step 16 で追加したコード: Eキーでインタラクト ---
            if (event.code === 'KeyE') {
                interact();
            }
            // --- Step 16 のコード ここまで ---
        });
        window.addEventListener('keyup', (event) => {
            keyState[event.code] = false;
        });
        // --- Step 16 のコード ここまで ---

        const clock = new THREE.Clock();

        // --- Step 16 で追加したコード: インタラクト処理 ---
        /**
         * プレイヤーのインタラクト処理
         */
        function interact() {
            // console.log("Eキーが押されました。インタラクトを試みます。"); // デバッグ用

            // 1. インタラクト可能な距離を定義
            const INTERACT_DISTANCE = 3.0; // 3メートル以内

            // 2. 最も近いチェストを探す
            let closestChest = null;
            let closestDistanceSq = Infinity; // 距離の二乗で比較（計算効率のため）

            for (const chest of loadedChests) {
                // 3. プレイヤーとチェストの距離の二乗を計算
                const distanceSq = playerMesh.position.distanceToSquared(chest.position);

                // 4. より近いチェストを更新
                if (distanceSq < closestDistanceSq) {
                    closestDistanceSq = distanceSq;
                    closestChest = chest;
                }
            }

            // 5. 最も近いチェストが見つかり、かつインタラクト距離内にあるかチェック
            if (closestChest && closestDistanceSq <= INTERACT_DISTANCE * INTERACT_DISTANCE) {
                // 6. インタラクトイベントの処理
                console.log("チェストを開けました！中身は青りんごです。");
                // 将来的には、UIを表示したり、インベントリにアイテムを追加したりする
            } else {
                // console.log("インタラクト可能なチェストが近くにありません。"); // デバッグ用
            }
        }
        // --- Step 16 のコード ここまで ---

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            const playerDirection = playerMesh.rotation.y;

            let moveX = 0;
            let moveZ = 0;

            if (keyState['KeyW']) {
                moveX -= Math.sin(playerDirection) * PLAYER_SPEED * delta;
                moveZ -= Math.cos(playerDirection) * PLAYER_SPEED * delta;
            }
            if (keyState['KeyS']) {
                moveX += Math.sin(playerDirection) * PLAYER_SPEED * delta;
                moveZ += Math.cos(playerDirection) * PLAYER_SPEED * delta;
            }
            if (keyState['KeyA']) {
                moveX -= Math.cos(playerDirection) * PLAYER_SPEED * delta;
                moveZ += Math.sin(playerDirection) * PLAYER_SPEED * delta;
            }
            if (keyState['KeyD']) {
                moveX += Math.cos(playerDirection) * PLAYER_SPEED * delta;
                moveZ -= Math.sin(playerDirection) * PLAYER_SPEED * delta;
            }

            playerMesh.position.x += moveX;
            playerMesh.position.z += moveZ;

            const terrainHeight = getTerrainHeightAt(playerMesh.position.x, playerMesh.position.z);
            playerMesh.position.y = terrainHeight + 1;

            const newPlayerChunkX = worldToChunkCoord(playerMesh.position.x);
            const newPlayerChunkY = worldToChunkCoord(playerMesh.position.y);
            const newPlayerChunkZ = worldToChunkCoord(playerMesh.position.z);

            if (newPlayerChunkX !== playerChunkX || newPlayerChunkY !== playerChunkY || newPlayerChunkZ !== playerChunkZ) {
                playerChunkX = newPlayerChunkX;
                playerChunkY = newPlayerChunkY;
                playerChunkZ = newPlayerChunkZ;

                const newVisibleChunks = calculateVisibleChunks(playerChunkX, playerChunkY, playerChunkZ);

                const newChunkKeysSet = new Set();
                newVisibleChunks.forEach(coord => newChunkKeysSet.add(getChunkKey(coord)));

                const keysToUnload = [];
                for (const key of loadedChunks.keys()) {
                    if (!newChunkKeysSet.has(key)) {
                         keysToUnload.push(key);
                    }
                }
                keysToUnload.forEach(key => unloadChunk(key));

                newVisibleChunks.forEach(coord => {
                     const key = getChunkKey(coord);
                     if (!loadedChunks.has(key)) {
                          loadChunk(coord);
                     }
                });

                console.log(`チャンク更新: ${keysToUnload.length} 個アンロード, ${newVisibleChunks.length - (loadedChunks.size - keysToUnload.length)} 個ロード`);
            }

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
        });

        console.log("Scene, Camera, Renderer, Player, Dynamic Chunk Loading, Noise-based Terrain, Randomized Trees, First-Person View, Shadows, and Interactive Chests initialized.");
        console.log("Click to lock pointer. WASD to move. Mouse to look around. Press 'V' to toggle view mode (FPS/TPS). Press 'E' to interact with nearby chests.");
        // --- 以前のコード ここまで ---

    </script>
</body>
</html>