<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D無限生成ゲーム</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.168.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.168.0/examples/jsm/"
            }
        }
        </script>
        <script type="module">
            import * as THREE from 'three';
            import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
            // --- Step 4/6/7 のコード: チャンク関連の定数と関数 ---
            const CHUNK_SIZE = 32;
            const RENDER_DISTANCE = 2;
    
            function worldToChunkCoord(worldCoord) {
                return Math.floor(worldCoord / CHUNK_SIZE);
            }
    
            function calculateVisibleChunks(playerChunkX, playerChunkY, playerChunkZ) {
                const chunksToLoad = [];
                for (let dx = -RENDER_DISTANCE; dx <= RENDER_DISTANCE; dx++) {
                    for (let dy = -RENDER_DISTANCE; dy <= RENDER_DISTANCE; dy++) {
                        for (let dz = -RENDER_DISTANCE; dz <= RENDER_DISTANCE; dz++) {
                            const cx = playerChunkX + dx;
                            const cy = playerChunkY + dy;
                            const cz = playerChunkZ + dz;
                            chunksToLoad.push({ cx, cy, cz });
                        }
                    }
                }
                return chunksToLoad;
            }
    
            const playerPosition = new THREE.Vector3(50, 10, -25); // プレイヤーの初期位置
    
            const playerChunkX = worldToChunkCoord(playerPosition.x);
            const playerChunkY = worldToChunkCoord(playerPosition.y);
            const playerChunkZ = worldToChunkCoord(playerPosition.z);
    
            console.log(`プレイヤーの位置: (${playerPosition.x}, ${playerPosition.y}, ${playerPosition.z}) m`);
            console.log(`プレイヤーの所属チャンク: (${playerChunkX}, ${playerChunkY}, ${playerChunkZ})`);
    
            const visibleChunks = calculateVisibleChunks(playerChunkX, playerChunkY, playerChunkZ);
            console.log(`描画範囲内のチャンク数: ${visibleChunks.length}`);
            // --- Step 4/6/7 のコード ここまで ---
    
    
            // --- Step 5/7 のコード: チャンクの可視化・床生成関連関数 ---
            function chunkToWorldCenter(chunkCoord) {
                return chunkCoord * CHUNK_SIZE + CHUNK_SIZE / 2;
            }
    
            function createChunkWireframe(cx, cy, cz, color = 0xffffff) {
                const chunkGeometry = new THREE.BoxGeometry(CHUNK_SIZE, CHUNK_SIZE, CHUNK_SIZE);
                const edgesGeometry = new THREE.EdgesGeometry(chunkGeometry);
                const lineMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: 1 });
                const chunkWireframe = new THREE.LineSegments(edgesGeometry, lineMaterial);
                const centerX = chunkToWorldCenter(cx);
                const centerY = chunkToWorldCenter(cy);
                const centerZ = chunkToWorldCenter(cz);
                chunkWireframe.position.set(centerX, centerY, centerZ);
                return chunkWireframe;
            }
    
            function createChunkFloor(cx, cy, cz) {
                const floorGeometry = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE);
                const r = Math.abs(cx * 30) % 256;
                const g = Math.abs(cy * 50) % 256;
                const b = Math.abs(cz * 70) % 256;
                const floorMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(`rgb(${r}, ${g}, ${b})`),
                    side: THREE.DoubleSide
                });
                const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
                const centerX = chunkToWorldCenter(cx);
                const centerZ = chunkToWorldCenter(cz);
                const bottomY = cy * CHUNK_SIZE;
                floorMesh.position.set(centerX, bottomY, centerZ);
                floorMesh.rotation.x = -Math.PI / 2;
                return floorMesh;
            }
            // --- Step 5/7 のコード ここまで ---
    
    
            // --- 以前のコード（Step 1-3）---
            const scene = new THREE.Scene();
            // カメラの初期位置は後でプレイヤーに合わせて設定するため、ここでは仮の値でも良い
            const camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
    
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
    
            // --- Step 8 で追加/変更したコード: プレイヤーとカメラ追従 ---
            // 1. プレイヤーメッシュの作成
            const playerGeometry = new THREE.BoxGeometry(1, 2, 1); // 幅1m, 高さ2m, 奥行き1m
            const playerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // 赤色
            const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
            // 2. プレイヤーの初期位置を設定
            playerMesh.position.copy(playerPosition); // playerPosition ベクトルの値をコピー
            scene.add(playerMesh); // シーンに追加
            console.log("プレイヤーメッシュを追加しました。");
    
            // 3. カメラ追従の設定 (OrbitControls を使用)
            const controls = new OrbitControls(camera, renderer.domElement);
            // カメラの注視点 (回転の中心) をプレイヤーに設定
            controls.target.copy(playerPosition);
            // カメラの初期位置をプレイヤーの後方・やや上方に設定
            // プレイヤー位置 + (後方10m, 上方5m)
            camera.position.set(
                playerPosition.x,
                playerPosition.y + 5, // 上方 5m
                playerPosition.z + 10  // 後方 10m (Z軸の正の方向が後方と仮定)
            );
            // カメラがプレイヤーを真正面から見るようにする (オプション)
            camera.lookAt(playerPosition);
    
            // (オプション) プレイヤーの位置に座標軸ヘルパーを追加して向きを確認
            const axesHelper = new THREE.AxesHelper(5); // 軸の長さ5m
            playerMesh.add(axesHelper); // プレイヤーメッシュの子要素として追加
    
            // (オプション) プレイヤー中心の回転のみに制限したい場合:
            // controls.enablePan = false; // パン（平行移動）を無効化
            // controls.enableZoom = false; // ズームを無効化
            // --- Step 8 のコード ここまで ---
    
            // --- Step 6/7 で追加/変更したコード: 動的なチャンク表示と床の追加 ---
            const chunkMeshes = [];
            visibleChunks.forEach(chunkCoord => {
                const { cx, cy, cz } = chunkCoord;
                let color = 0xffffff;
                if (cx === playerChunkX && cy === playerChunkY && cz === playerChunkZ) {
                    color = 0xffff00;
                }
                const chunkWireframe = createChunkWireframe(cx, cy, cz, color);
                scene.add(chunkWireframe);
                chunkMeshes.push(chunkWireframe);
    
                const floorMesh = createChunkFloor(cx, cy, cz);
                scene.add(floorMesh);
                chunkMeshes.push(floorMesh);
            });
    
            console.log(`描画範囲内の ${visibleChunks.length} 個のチャンク（ワイヤーフレームと床）を表示しました。`);
            // --- Step 6/7 のコード ここまで ---
    
            // --- 以前のコード（Step 1-3）---
            // 緑のテストキューブは、プレイヤー視点では邪魔かもしれないので、コメントアウトまたは削除
            /*
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.z = -5;
            scene.add(cube);
            */
    
            function animate() {
                requestAnimationFrame(animate);
    
                // --- Step 8 で追加したコード: アニメーションループでのカメラ更新 ---
                // controls.update() は OrbitControls の状態を更新するために必要
                controls.update();
                // --- Step 8 のコード ここまで ---
    
                // テストキューブの回転はコメントアウト
                // cube.rotation.x += 0.01;
                // cube.rotation.y += 0.01;
    
                renderer.render(scene, camera);
            }
    
            animate();
    
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
            });
    
            console.log("Scene, Camera, Renderer, OrbitControls, Player, and chunk floors initialized.");
            console.log("Camera is now following the player (red cube).");
            // --- 以前のコード ここまで ---
    
        </script>
    
</body>
</html>