<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D無限生成ゲーム</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; }
        #canvasWrapper {
            width: 100vw;
            height: 100vh;
            cursor: none;
        }
        /* --- Step 18 で追加したコード: UIのスタイル --- */
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none; /* UIがマウスイベントを妨げないように */
        }
        #message {
            margin-top: 5px;
            color: #ffff00; /* メッセージは黄色で表示 */
        }
        /* --- Step 18 のコード ここまで --- */
    </style>
</head>
<body>
    <div id="canvasWrapper">
        <canvas id="gameCanvas"></canvas>
    </div>
    <!-- --- Step 18 で追加したコード: UI要素 --- -->
    <div id="ui">
        <div>位置: <span id="playerPos">0, 0, 0</span></div>
        <div>チャンク: <span id="playerChunk">0, 0, 0</span></div>
        <div id="message"></div>
    </div>
    <!-- --- Step 18 のコード ここまで --- -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.168.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.168.0/examples/jsm/",
                "three/addons/math/ImprovedNoise.js": "https://unpkg.com/three@0.168.0/examples/jsm/math/ImprovedNoise.js"
            }
        }
    </script>
        <script type="module">
            // Step 11: Perlinノイズによる簡単な地形生成
            import * as THREE from 'three';
            import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
            // --- Step 11 で追加したコード: Perlinノイズライブラリのインポート ---
            import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
        const CHUNK_SIZE = 32;
        const TERRAIN_RESOLUTION = 16;
        const RENDER_DISTANCE = 2;

        function worldToChunkCoord(worldCoord) {
            return Math.floor(worldCoord / CHUNK_SIZE);
        }

        function calculateVisibleChunks(playerChunkX, playerChunkY, playerChunkZ) {
            const chunksToLoad = [];
            for (let dx = -RENDER_DISTANCE; dx <= RENDER_DISTANCE; dx++) {
                for (let dy = -RENDER_DISTANCE; dy <= RENDER_DISTANCE; dy++) {
                    for (let dz = -RENDER_DISTANCE; dz <= RENDER_DISTANCE; dz++) {
                        const cx = playerChunkX + dx;
                        const cy = playerChunkY + dy;
                        const cz = playerChunkZ + dz;
                        chunksToLoad.push({ cx, cy, cz });
                    }
                }
            }
            return chunksToLoad;
        }

        const playerPosition = new THREE.Vector3(50, 1, -25);
        const PLAYER_SPEED = 10.0;
        // --- Step 18 で変更したコード: ジャンプ関連定数を復活 ---
        const JUMP_FORCE = 8.0;
        const GRAVITY = 20.0;
        // --- Step 18 のコード ここまで ---

        const scene = new THREE.Scene();
        let playerChunkX = worldToChunkCoord(playerPosition.x);
        let playerChunkY = worldToChunkCoord(playerPosition.y);
        let playerChunkZ = worldToChunkCoord(playerPosition.z);

        console.log(`プレイヤーの初期位置: (${playerPosition.x}, ${playerPosition.y}, ${playerPosition.z}) m`);
        console.log(`プレイヤーの初期所属チャンク: (${playerChunkX}, ${playerChunkY}, ${playerChunkZ})`);

        const loadedChunks = new Map();
        const loadedChests = [];
        const loadedTrolls = [];

        function getChunkKey(chunkCoord) {
             return `${chunkCoord.cx},${chunkCoord.cy},${chunkCoord.cz}`;
        }

        function createNoiseTerrain(cx, cy, cz) {
            const perlin = new ImprovedNoise();
            const geometry = new THREE.BufferGeometry();
            const material = new THREE.MeshStandardMaterial({
                color: 0x00aa00,
                wireframe: false,
                flatShading: false
            });

            const segments = TERRAIN_RESOLUTION;
            const vertices = [];
            const indices = [];
            const uvs = [];

            const halfSize = CHUNK_SIZE / 2;
            const segmentSize = CHUNK_SIZE / segments;

            for (let z = 0; z <= segments; z++) {
                for (let x = 0; x <= segments; x++) {
                    const localX = x * segmentSize;
                    const localZ = z * segmentSize;
                    const worldX = cx * CHUNK_SIZE + localX;
                    const worldZ = cz * CHUNK_SIZE + localZ;
                    const scale = 0.05;
                    const height = perlin.noise(worldX * scale, 0, worldZ * scale) * 5;
                    const worldY = cy * CHUNK_SIZE + height;
                    vertices.push(localX - halfSize, worldY, localZ - halfSize);
                    uvs.push(x / segments, 1 - z / segments);
                }
            }

            for (let z = 0; z < segments; z++) {
                for (let x = 0; x < segments; x++) {
                    const a = x + (segments + 1) * z;
                    const b = x + (segments + 1) * (z + 1);
                    const c = (x + 1) + (segments + 1) * (z + 1);
                    const d = (x + 1) + (segments + 1) * z;
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }

            geometry.setIndex(indices);
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            geometry.computeVertexNormals();

            const terrainMesh = new THREE.Mesh(geometry, material);
            terrainMesh.position.set(
                chunkToWorldCenter(cx),
                0,
                chunkToWorldCenter(cz)
            );
            terrainMesh.receiveShadow = true;
            terrainMesh.castShadow = true;
            return terrainMesh;
        }

        function getTerrainHeightAt(x, z) {
            const chunkX = worldToChunkCoord(x);
            const chunkZ = worldToChunkCoord(z);
            const chunkY = playerChunkY;

            const key = getChunkKey({cx: chunkX, cy: chunkY, cz: chunkZ});
            const chunkData = loadedChunks.get(key);

            if (!chunkData || !chunkData.terrain) {
                return chunkY * CHUNK_SIZE;
            }

            return chunkY * CHUNK_SIZE;
        }

        function createChest() {
            const chestGeometry = new THREE.BoxGeometry(1, 0.8, 0.6);
            const chestMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const chestMesh = new THREE.Mesh(chestGeometry, chestMaterial);
            chestMesh.castShadow = true;
            chestMesh.receiveShadow = true;
            return chestMesh;
        }

        function placeChestsInChunk(chunkGroup, cx, cz) {
            if (Math.random() > 0.3) {
                return;
            }

            const localX = Math.random() * CHUNK_SIZE;
            const localZ = Math.random() * CHUNK_SIZE;
            const worldX = cx * CHUNK_SIZE + localX;
            const worldZ = cz * CHUNK_SIZE + localZ;
            const terrainHeight = getTerrainHeightAt(worldX, worldZ);

            const chest = createChest();

            const halfChunkSize = CHUNK_SIZE / 2;
            chest.position.set(
                localX - halfChunkSize,
                terrainHeight,
                localZ - halfChunkSize
            );

            chunkGroup.add(chest);
            loadedChests.push(chest);
        }

        function createTroll() {
            const trollGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            const trollMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
            const trollMesh = new THREE.Mesh(trollGeometry, trollMaterial);
            trollMesh.castShadow = true;
            trollMesh.receiveShadow = true;
            trollMesh.userData = { originalColor: new THREE.Color(0x00ff00) };
            return trollMesh;
        }

        function placeTrollsInChunk(chunkGroup, cx, cz) {
            if (Math.random() > 0.2) {
                return;
            }

            const localX = Math.random() * CHUNK_SIZE;
            const localZ = Math.random() * CHUNK_SIZE;
            const worldX = cx * CHUNK_SIZE + localX;
            const worldZ = cz * CHUNK_SIZE + localZ;
            const terrainHeight = getTerrainHeightAt(worldX, worldZ);

            const troll = createTroll();

            const halfChunkSize = CHUNK_SIZE / 2;
            troll.position.set(
                localX - halfChunkSize,
                terrainHeight + 0.8,
                localZ - halfChunkSize
            );

            chunkGroup.add(troll);
            loadedTrolls.push(troll);
        }

        // --- Step 18 で変更したコード: 木の生成調整 ---
        function placeTreesInChunk(chunkGroup, cx, cz) {
            // 1. 木の本数を減らす (例: 最大10本)
            const numTrees = Math.floor(Math.random() * 10) + 1; // 1 から 10本

            const halfChunkSize = CHUNK_SIZE / 2;
            const minDistance = 4.0; // 木と木の最小間隔
            const maxAttempts = 10; // 配置試行回数の上限

            const placedTrees = []; // このチャンク内に配置された木の位置を記録

            for (let i = 0; i < numTrees; i++) {
                let placed = false;
                let attempts = 0;

                while (!placed && attempts < maxAttempts) {
                    attempts++;
                    // 2. チャンク内でのランダムなローカルXZ座標を決定
                    //    端っこに置かれないように少し余白を設ける
                    const margin = 2.0;
                    const localX = margin + Math.random() * (CHUNK_SIZE - 2 * margin);
                    const localZ = margin + Math.random() * (CHUNK_SIZE - 2 * margin);
                    const worldX = cx * CHUNK_SIZE + localX;
                    const worldZ = cz * CHUNK_SIZE + localZ;

                    // 3. 最小間隔を満たしているかチェック
                    let tooClose = false;
                    for (const otherTreePos of placedTrees) {
                        const dx = worldX - otherTreePos.x;
                        const dz = worldZ - otherTreePos.z;
                        const distanceSq = dx * dx + dz * dz;
                        if (distanceSq < minDistance * minDistance) {
                            tooClose = true;
                            break;
                        }
                    }

                    if (!tooClose) {
                        // 4. 間隔が確保できたので配置
                        const terrainHeight = getTerrainHeightAt(worldX, worldZ);
                        const tree = createTree();
                        tree.position.set(
                            localX - halfChunkSize,
                            terrainHeight,
                            localZ - halfChunkSize
                        );
                        chunkGroup.add(tree);
                        // 配置した位置を記録
                        placedTrees.push({ x: worldX, z: worldZ });
                        placed = true;
                    }
                }
                // 試行回数を使い果たしても配置できなかった場合はスキップ
                if (!placed) {
                    console.warn(`チャンク (${cx}, ${cz}) への木の配置に失敗しました (試行回数オーバー)`);
                }
            }
        }

        function createTree() {
            const treeGroup = new THREE.Group();

            // パラメータのランダム化 (少し調整)
            const trunkHeight = 1.5 + Math.random() * 3.5; // 1.5m から 5m
            const trunkTopRadius = 0.08 + Math.random() * 0.25; // 0.08 から 0.33m
            const trunkBottomRadius = trunkTopRadius + 0.05 + Math.random() * 0.15; // 下部は少し太く
            const leavesRadius = 0.8 + Math.random() * 1.7; // 0.8 から 2.5m

            const leafHue = 0.3 + Math.random() * 0.1;
            const leafSaturation = 0.5 + Math.random() * 0.5;
            const leafLightness = 0.2 + Math.random() * 0.3;
            const leafColor = new THREE.Color(`hsl(${leafHue * 360}, ${leafSaturation * 100}%, ${leafLightness * 100}%)`);

            const trunkHue = 0.1;
            const trunkSaturation = 0.3 + Math.random() * 0.3;
            const trunkLightness = 0.1 + Math.random() * 0.2;
            const trunkColor = new THREE.Color(`hsl(${trunkHue * 360}, ${trunkSaturation * 100}%, ${trunkLightness * 100}%)`);

            const trunkGeometry = new THREE.CylinderGeometry(trunkTopRadius, trunkBottomRadius, trunkHeight, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: trunkColor });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            treeGroup.add(trunk);

            const leavesGeometry = new THREE.SphereGeometry(leavesRadius, 8, 8);
            const leavesMaterial = new THREE.MeshStandardMaterial({ color: leafColor });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.y = trunkHeight + leavesRadius * 0.7;
            leaves.castShadow = true;
            leaves.receiveShadow = true;
            treeGroup.add(leaves);

            return treeGroup;
        }
        // --- Step 18 のコード ここまで ---

        function loadChunk(chunkCoord) {
            const key = getChunkKey(chunkCoord);
            if (loadedChunks.has(key)) {
                return;
            }

            let color = 0xffffff;
            if (chunkCoord.cx === playerChunkX && chunkCoord.cy === playerChunkY && chunkCoord.cz === playerChunkZ) {
                color = 0xffff00;
            }

            const chunkGroup = new THREE.Group();
            chunkGroup.name = `chunk_${key}`;

            const wireframe = createChunkWireframe(chunkCoord.cx, chunkCoord.cy, chunkCoord.cz, color);
            const terrain = createNoiseTerrain(chunkCoord.cx, chunkCoord.cy, chunkCoord.cz);

            chunkGroup.add(wireframe);
            chunkGroup.add(terrain);

            placeTreesInChunk(chunkGroup, chunkCoord.cx, chunkCoord.cz);
            placeChestsInChunk(chunkGroup, chunkCoord.cx, chunkCoord.cz);
            placeTrollsInChunk(chunkGroup, chunkCoord.cx, chunkCoord.cz);

            scene.add(chunkGroup);

            loadedChunks.set(key, { group: chunkGroup, wireframe, terrain });
        }

        function unloadChunk(key) {
            const chunkData = loadedChunks.get(key);
            if (!chunkData) {
                return;
            }

            chunkData.group.traverse((child) => {
                const chestIndex = loadedChests.indexOf(child);
                if (chestIndex !== -1) {
                    loadedChests.splice(chestIndex, 1);
                }
                const trollIndex = loadedTrolls.indexOf(child);
                if (trollIndex !== -1) {
                    loadedTrolls.splice(trollIndex, 1);
                }
            });

            scene.remove(chunkData.group);

            if (chunkData.terrain) {
                chunkData.terrain.geometry.dispose();
                chunkData.terrain.material.dispose();
            }
            if (chunkData.wireframe) {
                chunkData.wireframe.geometry.dispose();
                chunkData.wireframe.material.dispose();
            }

            loadedChunks.delete(key);
        }

        const initialVisibleChunks = calculateVisibleChunks(playerChunkX, playerChunkY, playerChunkZ);
        initialVisibleChunks.forEach(chunkCoord => {
             loadChunk(chunkCoord);
        });
        console.log(`初期ロード: ${initialVisibleChunks.length} 個のチャンクをロードしました。`);

        function chunkToWorldCenter(chunkCoord) {
            return chunkCoord * CHUNK_SIZE + CHUNK_SIZE / 2;
        }

        function createChunkWireframe(cx, cy, cz, color = 0xffffff) {
            const chunkGeometry = new THREE.BoxGeometry(CHUNK_SIZE, CHUNK_SIZE, CHUNK_SIZE);
            const edgesGeometry = new THREE.EdgesGeometry(chunkGeometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: 1 });
            const chunkWireframe = new THREE.LineSegments(edgesGeometry, lineMaterial);
            const centerX = chunkToWorldCenter(cx);
            const centerY = chunkToWorldCenter(cy);
            const centerZ = chunkToWorldCenter(cz);
            chunkWireframe.position.set(centerX, centerY, centerZ);
            return chunkWireframe;
        }

        let isFirstPersonView = true;

        function toggleViewMode() {
            isFirstPersonView = !isFirstPersonView;
            if (isFirstPersonView) {
                playerMesh.visible = false;
                camera.position.set(0, 1.6, 0);
                console.log("視点を一人称に切り替えました。");
            } else {
                playerMesh.visible = true;
                camera.position.set(0, 2, -3);
                console.log("視点を三人称に切り替えました。");
            }
        }

        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            10000
        );

        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 0.5).normalize();
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        scene.add(directionalLight);

        const playerGeometry = new THREE.BoxGeometry(1, 2, 1);
        const playerMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
        playerMesh.position.copy(playerPosition);
        playerMesh.castShadow = true;
        playerMesh.receiveShadow = false;
        scene.add(playerMesh);
        console.log("プレイヤーメッシュを追加しました。");

        playerMesh.add(camera);
        camera.position.set(0, 1.6, 0);
        camera.rotation.set(0, 0, 0);
        playerMesh.visible = false;

        const MOUSE_SENSITIVITY = 0.002;
        let playerRotationX = 0;
        const PLAYER_ROTATION_X_MIN = -Math.PI / 2 + 0.1;
        const PLAYER_ROTATION_X_MAX = Math.PI / 2 - 0.1;
        let isPointerLocked = false;
        const canvasWrapper = document.getElementById('canvasWrapper');

        canvasWrapper.addEventListener('click', () => {
            if (!isPointerLocked) {
                canvasWrapper.requestPointerLock();
            }
        });

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = (document.pointerLockElement === canvasWrapper);
            console.log('Pointer Lock:', isPointerLocked ? 'ON' : 'OFF');
        });

        document.addEventListener('mousemove', (event) => {
            if (isPointerLocked) {
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;

                playerMesh.rotation.y -= movementX * MOUSE_SENSITIVITY;
                playerRotationX -= movementY * MOUSE_SENSITIVITY;
                playerRotationX = Math.max(PLAYER_ROTATION_X_MIN, Math.min(PLAYER_ROTATION_X_MAX, playerRotationX));
                camera.rotation.x = playerRotationX;
            }
        });

        const axesHelper = new THREE.AxesHelper(5);
        playerMesh.add(axesHelper);

        // --- Step 18 で変更したコード: キー入力処理と物理量の復活 ---
        const keyState = {};
        // --- Step 18 で追加したコード: 物理量 ---
        let velocityY = 0; // Y軸方向の速度
        let isOnGround = true; // 地面にいるかどうかのフラグ
        // --- Step 18 のコード ここまで ---
        window.addEventListener('keydown', (event) => {
            keyState[event.code] = true;

            if (event.code === 'KeyV') {
                toggleViewMode();
            }
            if (event.code === 'KeyE') {
                interact();
            }
            // --- Step 18 で追加したコード: ジャンプ処理 ---
            if (event.code === 'Space' && isOnGround) {
                 velocityY = JUMP_FORCE; // ジャンプ力分の上昇速度を設定
                 isOnGround = false; // 空中にいる状態に
                 console.log("Jump!");
            }
            // --- Step 18 のコード ここま
        });
        window.addEventListener('keyup', (event) => {
            keyState[event.code] = false;
        });
        // --- Step 18 のコード ここまで ---

        const clock = new THREE.Clock();

        // --- Step 18 で追加したコード: UI要素の取得 ---
        const playerPosElement = document.getElementById('playerPos');
        const playerChunkElement = document.getElementById('playerChunk');
        const messageElement = document.getElementById('message');
        let messageTimeout = null; // メッセージクリア用タイマー
        // --- Step 18 のコード ここまで ---

        function interact() {
            const INTERACT_DISTANCE = 3.0;

            let closestChest = null;
            let closestTroll = null;
            let closestDistanceSq = Infinity;

            for (const chest of loadedChests) {
                const distanceSq = playerMesh.position.distanceToSquared(chest.position);
                if (distanceSq < closestDistanceSq) {
                    closestDistanceSq = distanceSq;
                    closestChest = chest;
                }
            }

            for (const troll of loadedTrolls) {
                const distanceSq = playerMesh.position.distanceToSquared(troll.position);
                if (distanceSq < closestDistanceSq) {
                    closestDistanceSq = distanceSq;
                    closestChest = null;
                    closestTroll = troll;
                }
            }

            if (closestChest && closestDistanceSq <= INTERACT_DISTANCE * INTERACT_DISTANCE) {
                // --- Step 18 で変更したコード: UIメッセージ表示 ---
                showMessage("チェストを開けました！中身は青りんごです。");
                // --- Step 18 のコード ここまで ---
            } else if (closestTroll && closestDistanceSq <= INTERACT_DISTANCE * INTERACT_DISTANCE) {
                // --- Step 18 で変更したコード: UIメッセージ表示 ---
                showMessage("トロールに話しかけました。「こんにちは、冒険者よ！何か用かい？」");
                // --- Step 18 のコード ここま
            }
        }

        // --- Step 18 で追加したコード: UIメッセージ表示関数 ---
        function showMessage(text) {
            messageElement.textContent = text;
            // 既存のタイマーがあればクリア
            if (messageTimeout) {
                clearTimeout(messageTimeout);
            }
            // 3秒後にメッセージをクリアするタイマーを設定
            messageTimeout = setTimeout(() => {
                messageElement.textContent = '';
                messageTimeout = null;
            }, 3000);
        }
        // --- Step 18 のコード ここまで ---

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            const playerDirection = playerMesh.rotation.y;

            let moveX = 0;
            let moveZ = 0;

            if (keyState['KeyW']) {
                moveX -= Math.sin(playerDirection) * PLAYER_SPEED * delta;
                moveZ -= Math.cos(playerDirection) * PLAYER_SPEED * delta;
            }
            if (keyState['KeyS']) {
                moveX += Math.sin(playerDirection) * PLAYER_SPEED * delta;
                moveZ += Math.cos(playerDirection) * PLAYER_SPEED * delta;
            }
            if (keyState['KeyA']) {
                moveX -= Math.cos(playerDirection) * PLAYER_SPEED * delta;
                moveZ += Math.sin(playerDirection) * PLAYER_SPEED * delta;
            }
            if (keyState['KeyD']) {
                moveX += Math.cos(playerDirection) * PLAYER_SPEED * delta;
                moveZ -= Math.sin(playerDirection) * PLAYER_SPEED * delta;
            }

            playerMesh.position.x += moveX;
            playerMesh.position.z += moveZ;

            // --- Step 18 で変更したコード: ジャンプと重力処理 ---
            // 1. ジャンプ力と重力を適用
            velocityY -= GRAVITY * delta; // 速度に重力を加算
            playerMesh.position.y += velocityY * delta; // 速度を使って位置を更新

            // 2. 着地判定と位置修正
            const terrainHeight = getTerrainHeightAt(playerMesh.position.x, playerMesh.position.z);
            // プレイヤーの足元 (中心Y - 高さ/2 = 1 - 1 = 0) が地形の高さ以上になったら着地
            if (playerMesh.position.y <= terrainHeight + 1.0) { // +1.0 はプレイヤーの中心から足元まで
                playerMesh.position.y = terrainHeight + 1.0; // 地面の上に立たせる
                velocityY = 0; // Y軸速度をリセット
                isOnGround = true; // 地面にいる状態に
            }
            // --- Step 18 のコード ここまで ---

            const NPC_REACTION_DISTANCE = 5.0;
            const NPC_REACTION_DISTANCE_SQ = NPC_REACTION_DISTANCE * NPC_REACTION_DISTANCE;

            for (const troll of loadedTrolls) {
                const distanceSq = playerMesh.position.distanceToSquared(troll.position);
                const trollMaterial = troll.material;

                if (distanceSq <= NPC_REACTION_DISTANCE_SQ) {
                    trollMaterial.color.set(0xffff00);
                } else {
                    trollMaterial.color.copy(troll.userData.originalColor);
                }
            }

            const newPlayerChunkX = worldToChunkCoord(playerMesh.position.x);
            const newPlayerChunkY = worldToChunkCoord(playerMesh.position.y);
            const newPlayerChunkZ = worldToChunkCoord(playerMesh.position.z);

            // --- Step 18 で追加したコード: UI更新 ---
            // プレイヤー位置の更新
            playerPosElement.textContent = `${playerMesh.position.x.toFixed(2)}, ${playerMesh.position.y.toFixed(2)}, ${playerMesh.position.z.toFixed(2)}`;
            // プレイヤーチャンクの更新
            playerChunkElement.textContent = `${newPlayerChunkX}, ${newPlayerChunkY}, ${newPlayerChunkZ}`;
            // --- Step 18 のコード ここまで ---

            if (newPlayerChunkX !== playerChunkX || newPlayerChunkY !== playerChunkY || newPlayerChunkZ !== playerChunkZ) {
                playerChunkX = newPlayerChunkX;
                playerChunkY = newPlayerChunkY;
                playerChunkZ = newPlayerChunkZ;

                const newVisibleChunks = calculateVisibleChunks(playerChunkX, playerChunkY, playerChunkZ);

                const newChunkKeysSet = new Set();
                newVisibleChunks.forEach(coord => newChunkKeysSet.add(getChunkKey(coord)));

                const keysToUnload = [];
                for (const key of loadedChunks.keys()) {
                    if (!newChunkKeysSet.has(key)) {
                         keysToUnload.push(key);
                    }
                }
                keysToUnload.forEach(key => unloadChunk(key));

                newVisibleChunks.forEach(coord => {
                     const key = getChunkKey(coord);
                     if (!loadedChunks.has(key)) {
                          loadChunk(coord);
                     }
                });

                console.log(`チャンク更新: ${keysToUnload.length} 個アンロード, ${newVisibleChunks.length - (loadedChunks.size - keysToUnload.length)} 個ロード`);
            }

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
        });

        console.log("Scene, Camera, Renderer, Player, Dynamic Chunk Loading, Noise-based Terrain, Randomized Trees, First-Person View, Shadows, Interactive Chests, Trolls, UI, and Jump initialized.");
        console.log("Click to lock pointer. WASD to move. Mouse to look around. Press 'V' to toggle view mode (FPS/TPS). Press 'E' to interact. Press 'Space' to jump.");
        // --- 以前のコード ここまで ---

    </script>
</body>
</html>