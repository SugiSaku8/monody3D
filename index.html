<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D無限生成ゲーム</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.168.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.168.0/examples/jsm/"
            }
        }
        </script>
        <script type="module">
            // Step 10: チャンクの動的ロード/アンロード（プレイヤー追従） (エラー修正版)
            import * as THREE from 'three';
            import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
            // --- Step 4/6/7/8/9 のコード: チャンク関連の定数と関数 ---
            const CHUNK_SIZE = 32;
            const RENDER_DISTANCE = 2;
    
            function worldToChunkCoord(worldCoord) {
                return Math.floor(worldCoord / CHUNK_SIZE);
            }
    
            function calculateVisibleChunks(playerChunkX, playerChunkY, playerChunkZ) {
                const chunksToLoad = [];
                for (let dx = -RENDER_DISTANCE; dx <= RENDER_DISTANCE; dx++) {
                    for (let dy = -RENDER_DISTANCE; dy <= RENDER_DISTANCE; dy++) {
                        for (let dz = -RENDER_DISTANCE; dz <= RENDER_DISTANCE; dz++) {
                            const cx = playerChunkX + dx;
                            const cy = playerChunkY + dy;
                            const cz = playerChunkZ + dz;
                            chunksToLoad.push({ cx, cy, cz });
                        }
                    }
                }
                return chunksToLoad;
            }
    
            // --- Step 9 で追加したコード: プレイヤー関連の定数 ---
            const playerPosition = new THREE.Vector3(50, 1, -25);
            const PLAYER_SPEED = 10.0;
            const JUMP_FORCE = 8.0;
            const GRAVITY = 20.0;
            // --- Step 9 のコード ここまで ---
    
            // --- Step 10 で追加したコード: チャンク管理 ---
            // *** 修正: scene の宣言を関数定義より前に移動 ***
            const scene = new THREE.Scene(); // <-- 重要: ここに移動
    
            // プレイヤーの現在のチャンク座標 (初期値)
            let playerChunkX = worldToChunkCoord(playerPosition.x);
            let playerChunkY = worldToChunkCoord(playerPosition.y);
            let playerChunkZ = worldToChunkCoord(playerPosition.z);
    
            console.log(`プレイヤーの初期位置: (${playerPosition.x}, ${playerPosition.y}, ${playerPosition.z}) m`);
            console.log(`プレイヤーの初期所属チャンク: (${playerChunkX}, ${playerChunkY}, ${playerChunkZ})`);
    
            // ロード済みチャンクを管理するMap (キー: "cx,cy,cz", 値: { wireframe, floor })
            const loadedChunks = new Map();
    
            /**
             * チャンク座標オブジェクトからキー文字列を生成
             * @param {{cx: number, cy: number, cz: number}} chunkCoord - チャンク座標オブジェクト
             * @returns {string} キー文字列 ("cx,cy,cz")
             */
            function getChunkKey(chunkCoord) {
                 return `${chunkCoord.cx},${chunkCoord.cy},${chunkCoord.cz}`;
            }
    
            /**
             * 指定されたチャンクをロード（生成・表示）する
             * @param {{cx: number, cy: number, cz: number}} chunkCoord - ロードするチャンクの座標
             */
            function loadChunk(chunkCoord) {
                const key = getChunkKey(chunkCoord);
                if (loadedChunks.has(key)) {
                    return;
                }
    
                let color = 0xffffff;
                if (chunkCoord.cx === playerChunkX && chunkCoord.cy === playerChunkY && chunkCoord.cz === playerChunkZ) {
                    color = 0xffff00;
                }
    
                const wireframe = createChunkWireframe(chunkCoord.cx, chunkCoord.cy, chunkCoord.cz, color);
                const floor = createChunkFloor(chunkCoord.cx, chunkCoord.cy, chunkCoord.cz);
    
                scene.add(wireframe); // <-- scene がここで使える
                scene.add(floor);
    
                loadedChunks.set(key, { wireframe, floor });
            }
    
            /**
             * 指定されたチャンクをアンロード（削除・メモリ解放）する
             * @param {string} key - アンロードするチャンクのキー ("cx,cy,cz")
             */
            function unloadChunk(key) {
                const chunkData = loadedChunks.get(key);
                if (!chunkData) {
                    return;
                }
    
                scene.remove(chunkData.wireframe); // <-- scene がここで使える
                scene.remove(chunkData.floor);
    
                loadedChunks.delete(key);
            }
    
            // 初回ロード: プレイヤー周囲のチャンクをロード
            const initialVisibleChunks = calculateVisibleChunks(playerChunkX, playerChunkY, playerChunkZ);
            initialVisibleChunks.forEach(chunkCoord => {
                 loadChunk(chunkCoord); // <-- loadChunk がここで呼び出される
            });
            console.log(`初期ロード: ${initialVisibleChunks.length} 個のチャンクをロードしました。`);
            // --- Step 10 のコード ここまで ---
    
    
            // --- Step 5/7/8 のコード: チャンクの可視化・床生成・プレイヤー関連関数 ---
            function chunkToWorldCenter(chunkCoord) {
                return chunkCoord * CHUNK_SIZE + CHUNK_SIZE / 2;
            }
    
            function createChunkWireframe(cx, cy, cz, color = 0xffffff) {
                const chunkGeometry = new THREE.BoxGeometry(CHUNK_SIZE, CHUNK_SIZE, CHUNK_SIZE);
                const edgesGeometry = new THREE.EdgesGeometry(chunkGeometry);
                const lineMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: 1 });
                const chunkWireframe = new THREE.LineSegments(edgesGeometry, lineMaterial);
                const centerX = chunkToWorldCenter(cx);
                const centerY = chunkToWorldCenter(cy);
                const centerZ = chunkToWorldCenter(cz);
                chunkWireframe.position.set(centerX, centerY, centerZ);
                return chunkWireframe;
            }
    
            function createChunkFloor(cx, cy, cz) {
                const floorGeometry = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE);
                const r = Math.abs(cx * 30) % 256;
                const g = Math.abs(cy * 50) % 256;
                const b = Math.abs(cz * 70) % 256;
                const floorMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(`rgb(${r}, ${g}, ${b})`),
                    side: THREE.DoubleSide
                });
                const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
                const centerX = chunkToWorldCenter(cx);
                const centerZ = chunkToWorldCenter(cz);
                const bottomY = cy * CHUNK_SIZE;
                floorMesh.position.set(centerX, bottomY, centerZ);
                floorMesh.rotation.x = -Math.PI / 2;
                return floorMesh;
            }
            // --- Step 5/7/8 のコード ここまで ---
    
    
            // --- 以前のコード（Step 1-3）---
            // *** 修正: scene の宣言は Step 10 に移動したので、ここでは削除 ***
            // const scene = new THREE.Scene(); // <-- この行を削除
            const camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
    
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            // --- 以前のコード ここまで ---
    
    
            // --- Step 8 で追加/変更したコード: プレイヤーとカメラ追従 ---
            const playerGeometry = new THREE.BoxGeometry(1, 2, 1);
            const playerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
            playerMesh.position.copy(playerPosition);
            scene.add(playerMesh); // <-- scene がここで使える
            console.log("プレイヤーメッシュを追加しました。");
    
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.target.copy(playerPosition);
            camera.position.set(
                playerPosition.x,
                playerPosition.y + 5,
                playerPosition.z + 10
            );
            camera.lookAt(playerPosition);
    
            const axesHelper = new THREE.AxesHelper(5);
            playerMesh.add(axesHelper);
            // --- Step 8 のコード ここまで ---
    
    
            // --- Step 9 で追加したコード: キーボード入力と移動処理 ---
            const keyState = {};
            window.addEventListener('keydown', (event) => {
                keyState[event.code] = true;
            });
            window.addEventListener('keyup', (event) => {
                keyState[event.code] = false;
            });
    
            let velocityY = 0;
            let isOnGround = true;
            const clock = new THREE.Clock();
            // --- Step 9 のコード ここまで ---
    
    
            function animate() {
                requestAnimationFrame(animate);
    
                // --- Step 9 で追加したコード: アニメーションループでの移動と物理処理 ---
                const delta = clock.getDelta();
    
                if (keyState['Space'] && isOnGround) {
                    velocityY = JUMP_FORCE;
                    isOnGround = false;
                    console.log("Jump!");
                }
    
                velocityY -= GRAVITY * delta;
                playerMesh.position.y += velocityY * delta;
    
                const floorHeight = playerChunkY * CHUNK_SIZE;
                if (playerMesh.position.y <= floorHeight + 1) {
                    playerMesh.position.y = floorHeight + 1;
                    velocityY = 0;
                    isOnGround = true;
                }
    
                const playerDirection = camera.rotation.y;
    
                let moveX = 0;
                let moveZ = 0;
    
                if (keyState['KeyW']) {
                    moveX -= Math.sin(playerDirection) * PLAYER_SPEED * delta;
                    moveZ -= Math.cos(playerDirection) * PLAYER_SPEED * delta;
                }
                if (keyState['KeyS']) {
                    moveX += Math.sin(playerDirection) * PLAYER_SPEED * delta;
                    moveZ += Math.cos(playerDirection) * PLAYER_SPEED * delta;
                }
                if (keyState['KeyA']) {
                    moveX -= Math.cos(playerDirection) * PLAYER_SPEED * delta;
                    moveZ += Math.sin(playerDirection) * PLAYER_SPEED * delta;
                }
                if (keyState['KeyD']) {
                    moveX += Math.cos(playerDirection) * PLAYER_SPEED * delta;
                    moveZ -= Math.sin(playerDirection) * PLAYER_SPEED * delta;
                }
    
                playerMesh.position.x += moveX;
                playerMesh.position.z += moveZ;
    
                controls.target.copy(playerMesh.position);
                controls.update();
                // --- Step 9 のコード ここまで ---
    
    
                // --- Step 10 で追加したコード: 動的チャンクロード/アンロード ---
                const newPlayerChunkX = worldToChunkCoord(playerMesh.position.x);
                const newPlayerChunkY = worldToChunkCoord(playerMesh.position.y);
                const newPlayerChunkZ = worldToChunkCoord(playerMesh.position.z);
    
                if (newPlayerChunkX !== playerChunkX || newPlayerChunkY !== playerChunkY || newPlayerChunkZ !== playerChunkZ) {
                    playerChunkX = newPlayerChunkX;
                    playerChunkY = newPlayerChunkY;
                    playerChunkZ = newPlayerChunkZ;
    
                    const newVisibleChunks = calculateVisibleChunks(playerChunkX, playerChunkY, playerChunkZ);
    
                    const newChunkKeysSet = new Set();
                    newVisibleChunks.forEach(coord => newChunkKeysSet.add(getChunkKey(coord)));
    
                    const keysToUnload = [];
                    for (const key of loadedChunks.keys()) {
                        if (!newChunkKeysSet.has(key)) {
                             keysToUnload.push(key);
                        }
                    }
                    keysToUnload.forEach(key => unloadChunk(key));
    
                    newVisibleChunks.forEach(coord => {
                         const key = getChunkKey(coord);
                         if (!loadedChunks.has(key)) {
                              loadChunk(coord);
                         }
                    });
    
                    console.log(`チャンク更新: ${keysToUnload.length} 個アンロード, ${newVisibleChunks.length - (loadedChunks.size - keysToUnload.length)} 個ロード`);
                }
                // --- Step 10 のコード ここまで ---
    
                renderer.render(scene, camera);
            }
    
            animate();
    
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
            });
    
            console.log("Scene, Camera, Renderer, OrbitControls, Player, and Dynamic Chunk Loading initialized.");
            console.log("Player movement (WASD) and jump (Space) are enabled. Chunks load/unload as you move.");
            // --- 以前のコード ここまで ---
    
        </script>
    
</body>
</html>